use nomt::hasher::Sha2Hasher;
use nomt::{KeyReadWrite, Nomt, Options, Root, SessionParams, Witness, WitnessMode};
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{SOV_NOMT_RISC0_ELF, SOV_NOMT_RISC0_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use sha2::Digest;

const NOMT_DB_FOLDER: &str = "nomt_db";

fn commit_batch() -> anyhow::Result<(Root, Root, Witness)> {
    // Define the options used to open NOMT
    let mut opts = Options::new();
    opts.path(NOMT_DB_FOLDER);
    opts.commit_concurrency(1);

    // Open NOMT database, it will create the folder if it does not exist
    let nomt = Nomt::<Sha2Hasher>::open(opts)?;

    // Create a new Session object
    //
    // During a session, the backend is responsible for returning read keys
    // and receiving hints about future writes
    //
    // Writes do not occur immediately, instead,
    // they are cached and applied all at once later on
    let session =
        nomt.begin_session(SessionParams::default().witness_mode(WitnessMode::read_write()));

    // Here we will move the data saved under b"key1" to b"key2" and deletes it
    //
    // NOMT expects keys to be uniformly distributed across the key space
    let key_path_1 = sha2::Sha256::digest(b"key1").into();
    let key_path_2 = sha2::Sha256::digest(b"key2").into();

    // First, read what is under key_path_1
    //
    // `read` will immediately return the value present in the database
    let value = session.read(key_path_1)?;
    let value_2 = Some(vec![1, 2, 3]);

    // We are going to perform writes on both key-paths, so we have NOMT warm up the on-disk
    // data for both.
    session.warm_up(key_path_1);
    session.warm_up(key_path_2);

    // Retrieve the previous value of the root before committing changes
    let prev_root = nomt.root();

    // To commit the batch to the backend we need to collect every
    // performed actions into a vector where items are ordered by the key_path
    let mut actual_access: Vec<_> = vec![
        (key_path_1, KeyReadWrite::ReadThenWrite(value.clone(), None)),
        (key_path_2, KeyReadWrite::Write(value_2.clone())),
    ];
    actual_access.sort_by_key(|(k, _)| *k);

    // The final step in handling a session involves committing all changes
    // to update the trie structure and obtaining the new root of the trie,
    // along with a witness and the witnessed operations.
    let mut finished = session.finish(actual_access).unwrap();

    // This field is set because the finished session was configured with
    // `WitnessMode::read_write`.
    let witness = finished.take_witness().unwrap();
    let root = finished.root();
    finished.commit(&nomt)?;

    Ok((prev_root, root, witness))
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    let (prev_root, new_root, witness) = commit_batch().unwrap();

    // For example:
    let input: u32 = 15 * u32::pow(2, 27) + 1;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .write(&prev_root.into_inner())
        .unwrap()
        .write(&witness)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, SOV_NOMT_RISC0_ELF).unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    // let _output: u32 = receipt.journal.decode().unwrap();
    let new_root_guest: [u8; 32] = receipt.journal.decode().expect("Failed to decode new root");
    tracing::info!(
        "New root. Host: {}, Guest {}",
        hex::encode(new_root.as_ref()),
        hex::encode(&new_root_guest)
    );

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(SOV_NOMT_RISC0_ID).unwrap();
    tracing::info!("Receipt verified successfully!");
}
